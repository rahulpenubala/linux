--help
man man -> to get section definitions
apropos -s <> keyword OR man -k -s <> keyword
----------------------------------------------------
mkdir -p -> create parents if they does not exists, no error if the directory already exists
mv -> does not require "r" option
----------------------------------------------------
inode = the location of data blocks + meta data of a file (permissions, access times etc)
hardlink is nothing but a filename that points to inode
"stat" command can be used to check the details of inode
ln target_file_name dst_file_name -> to cretae hard link
hard links cannot be created for directories, and should be created wthin same file system
to remove the data blocks, all links should be removed/deleted
----------------------------------------------------
ln -s target_file_name dst_file_name -> softlink can be created for directories & other filesystems
ls -l -> output shows "l" for links
readlink <link> command is used to read the full path of target file
softlink permissions does not matter, only hardlink permissions applies
----------------------------------------------------
stickybit - if set, onlu user owner can remove it (recognized by t/T in others permissions)
suid - if set, will be executed as its user, even if others are doing it (s/S in owner permissions)
sgid - if set, will be executed as its group, even if others are doing it (s/S in group permissions)
----------------------------------------------------
vim - i -insert, /-search, :wq!, q!, dd, yy, pp
----------------------------------------------------
find <path> -name xyz -size +10M -mmin +5 -perm 644 (-i -o -not)
We can search based on time, permissions, size & name 
----------------------------------------------------
head/tail (-f), sed -i s/xyz/abc/g, cut -d '' -f, sort file.txt | uniq, sort -n, sdiff file1 file2
---------------------------------------------------
grep -ivrw, zgrep, egrep
--------------------------------------
^ - start with
$ - end with
. - match any "1" character (to escape regex meaning, and search for ".", use "\")
* - repeat prev char 0 or more times
+ - repeat prev char 1 or more times (egrep, as + is not basic regex, so we could either use "\" to get regex meaning Or egrep)
{} - {3,},{,3},{3},{3,5} - repeat the prev char that many times
? - repeat prev char 0 or 1 times
| - this or that
() - subexpression
[] - [a-z],[aug][shyd6f] --> sets
[^] - negated sets [^abc]
example for ipv4 - "-w [0-9]{1,3}\.){3}[0-9]{1,3}"
--------------------------------------
tar --create --append --list --file --directory (where to untar the files) --extract --gzip (combine archiving & compression)
sudo - should be used if we dont want to miss any files that requires elevated permissions
--------------------------------------
gzip -k -> keep the original file
gzip -l -> list, can be used to check compression ratio
zip -r (recursive for directories) -> Zip can do both archiving & compression
---------------------------------------
pre req: remote should have SSH daemon running
rsync -a <local_path> user@host:<remote_path>
---------------------------------------
pre req: disconnect the device to prevent any new changes
sudo dd if=/dev/vda of=image.raw bs=1MB status=running
--------------------------------------
< -> regular input
<<EOF EOF -> heredoc
<<< -> herestring
> or 1> -> standard output
>> -> append output
2>/dev/null -> standard error
> xyz 2>&1 -> redirecting both standard o/p & error o/p to same location
column -t -> to format redirected standard output in columns
----------------------------------------
Certificate is used from encrypting traffic from browser to website, and authenticate the website
openssl req -> is used to generate CSR & private key
openssl req X509 -> creates self signed certs
openssl X509 -> useful to view the contents of the cert
-----------------------------------------
sudo systemctl reboot --force (last resort)
sudo systemctl poweroff --force (last resort)
sudo shutdown -r (restart) 02:00 'banner'
----------------------------------------
After booting up the system, init system (systemd) looks for units (service, socket, device, timer) and starts the processes in order
service units - manage the life cycle of services
systemctl list-units --type service --all
man systemd.service
systemctl cat sshd.service
systemctl edit --full sshd.service
systemctl revert sshd.service - revert to factory settings
systemctl status sshd.service
systemctl enable sshd.service - "enable --now" -> Both enables & starts the service
systemctl disable sshd.service - do not disabled sshd
systemctl stop/start sshd.service
systemctl restart sshd.service - after changing the config of any service, but, destructive
systemctl reload sshd.service - alternative option to restart, non-destructive
systemctl reload-or-restart sshd.service - not all services support reload, so restart after reload attempt
systemctl mask/unmask atd.service - to prevent other services from starting/enabling a service

If there are any edits/new additions to service unit files
/lib/systemd/system -> contains templates
/etc/systemd/system -> contains synlinks
If we want a new service unit, create a file in /etc/systemd/system
[unit] - description, after, documentation etc
[service] - env variable, star prep section, start section, relaod section, restart secions etc 
[install] - Alias is not needed if the file is created in /etc/systemd/system, WantedBy which service units
systemctl daemon-reload, then start/enable the service

**To avoid restartloop (which could cause load on system), add restart delay
**target is a collection of servce to achieve some purpose. network.target -> all service required for network functioning, multi-user.target etc
--------------------------------------------------------------------
ps aux -all processes, all users, user friendly [CPU percentage is per core, process time is also per core, [] - kernal processes]
ps u -U - specific use
ps u <pid> - specific process
ps laux & ps faux - l -> nice values, f-> forest view
Nice values are from -20 to +19, more nicer if 19. nice -n <number> -> need root prev for negative values
renice <number> <pid> -> regular user canonly renice once per session
Children processed inherit parent process nice values

kill -L (SIGHUP - Reload, SIGQUIT - Graceful terminate +core dump, SIGKILL - force kill, SIGTERM - graceful term + default)
kill -SIGQUIT -QUIT -3 <pid>
pgrep -a <keyword> & pkill -9 <keyword> are used in combination to kill multiple processes of same name

Ctrl+C -> kill a process
Ctrl+Z -> stop & move a process to back ground
[CMD] & -> run the active process in background
jobs -> to check back ground processes
fg <jobid> -> to bring background process to foreground
bg <jobid> -> to resume the process in background

lsof -p <pid> -> shows the files used by a process
lsof <file_path> -> shows the process of the file
--------------------------------------------------------------
rsyslog stores logs in /var/logs - sshd, firewall, boot etc
/var/logs/messages -> system log files

which <cmd_name> -> full path of the command
journalctl <cmd> | -u <service_unit> | -p <priority> | --list-boots | --boot <bootid>
By default, journalctl logs are kept in memory, and lost after reboot. 
To prevent it, we can store them in /var/logs/journalctl by adjusting config - /etc/systemd/journald.conf

last -> all login in recent times
lastlog -> last login of each user
-------------------------------------------------------------
/etc/crontab -> use it only as definition file. Edit personal crontabs
crontab -l -e -r -> Comibe with which [CMD] for full path
sudo crontab -u <username> -> as a root working on other user's crontabs
/etc/cron.hourly/ -> shell scripts are placed here with enough permissions & should not have ".sh" extension
/etc/cron.daily/
/etc/cron.weekly/
/etc/cron.monthly/

/etc/anacrontab -> minimum frequency is 1 day. It makes sure that missed jobs are processed when the system is powered on. 
To avoid parellel processing of jobs, avoid delays
anacron -T -> to verify sysntax, unlike crontab we cant test it by shutting down the system

at 15:00 '15 August 2024' 'now + 30 minutes'
Ctrl+D to save the job
atq -> list the jobs
at -c <id> -> to see the contant of a job
atrm <id> -> to remove a job
-----------------------------------------------------
We can push job's output to system logs/journald using systemd-cat --identifier <> --priority <>
cron, anacron, at logs are also pushed to /var/logs/cron
-----------------------------------------------------
apt update -> to update the local copy/index/package manager database which contains the latest info of repositories 
& show us the possible upgrades. Should be chaned with install/upgrade
apt upgrade -> actual upgrade og packages
apt upgrade/install -> automatically downloads dependencies
apt remove <package>
apt autoremove -> to remove unused dependencies
apt autoremove <package> -> combing both remove & autoremove
apt search <package> --name-only -> search packages using names in DB
apt show <package> -> once we have the package name, find more details about it
dpkg --list-files <package> --> list the files used by this package
dpkg --search <file_path> --> shows the package that is using this file path
------------------------------------------------------
/etc/apt/sources.list -> default repositories list
/etc/apt/keyrings -> download & dearmor (gpg --dearmor key_name) the public key & save it here
/etc/apt/sources.list.d -> add a file with .list extension & add repo details siagned by keyring
apt update -> to check if everything is correctly configured
------------------------------------------------------
sysctl -a (list the kernal param) -w (non persistent change) -p /etc/sysctl/d/xyz.conf (persistent change)
------------------------------------------------------
useradd -s (chnage shell) -d (home direcoty) --defaults (to verify defaults)
 --uid (to assign custom user ID) --system (to create system users, without home directory)
    -> creates user, default group, home folder, bash shell & copies /etc/skel to home folder
userdel -r (remove home directory) -> without "r", it only deleted user & group
passwd - create the password, lock/unlock the password
/etc/passwd -> contains the users & group information - "ls -ln"
id/whoami -> to check current user details
usermod -> to change login, group (secondary, primary), home, shell, lock (only password based), expiration date
chage -> to expire the password, so the user need to create a new one
------------------------------------------------------
groups (to check the groups), groupadd, groupmod, groupdel
gpasswd --add --delete -> to add users to groups
usermod -g (primary group) -G (secondary groups)
-----------------------------------------------------
printenv -> to print env variables
.bashrc (env variables) & .bash_profile (for start up scripts) - source
/etc/environment & /etc/profile.d/ -> systemwide variables & scripts
----------------------------------------------------
easiest way to give root previliges is to assign the user to wheel group
To fine tume, we should add entries in /etc/sudoers using "visudo" - no password, restricted command, run as different user etc
lock root password (su -), only if users have sudo permissions (sudo -i) 
----------------------------------------------------
/etc/nsswitch.conf tells the system to look for passwd & group details in files & ldap
/etc/nslcd.conf contains the url & other detals of ldap
getent passwd/group --service ldap
user resouce limits can be configured using /etc/security/limits.conf
-----------------------------------------------------
ip link, ip -c address -> can manipulate them using ip commands, but temporary
netplan or nmcli for permanent network configuraions & also add DNS on interface level
ip route, route -n -> better option, ip route add/delete, ip neighbour
/etc/resolved.conf -> golbal DNS
/etc/hosts -> takes more priority than DNS
-----------------------------------------------------





